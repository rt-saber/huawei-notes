# huawei-notes
Notes from my reverse engineering of the Huawei USG6000 firewall firmware. This repository was not meant to be public, only reason I haven't switched it to private is because hopefully it can one day help someone else doing reverse engineering on this device firmwares.

---

Most binaries extracted from the firmware have their debug symbols.

# svn.out

SVN in Huawei context can have several meanings, here I think it is related to the VPN client. 

```
ELF 64-bit MSB shared object, MIPS, MIPS64 rel2 version 1 (SYSV), dynamically linked, interpreter /lib64/ld.so.1, for GNU/Linux 2.6.34, with debug_info, not stripped
```

## Functions

- `VOS_StrStr` is a wrapper around `strstr()`, it does NULL checks.

#### WPM_HTTP_RetInit
```c

```

Compiles 7 regex pattern one after the other. If any fails then it returns 1.
   
REGEX 1: HTTP Request Line
- Format: "METHOD URI HTTP_VERSION"
- Example: "GET /default.html HTTP/1.1"

REGEX 2: Web Proxy URL Path
- Format: "/webproxy/NUM/NUM/NUM/PROTO/HOST,PARAMS"
- Example: "/webproxy/123/456/789/https/example.com,timeout=30"

REGEX 3: Host:Port
- Format: "HOST:PORT"
- Example: "example.com:8080"

REGEX 4: HTTP Header
- Format: "HEADER: VALUE"
- Example: "Content-Type: text/html"

REGEX 5: Cookie (SVNWebProxyCookie)
- Format: "SVNWebProxyCookie=value"
- Example: "SVNWebProxyCookie=123"

REGEX 6: HTTP Response
- Format: "HTTP_VERSION CODE MESSAGE"
- Example: "HTTP/1.1 200 OK"

REGEX 7: Key-Value
- Format: "KEY = VALUE"
- Example: "timeout=30"

---
Cookie: no length limit. This cookie is also used by the `WPM_HTTP_GetTokenId` function

#### WPM_HTTP_GetTokenId
```c
INT32 WPM_HTTP_GetTokenId(UCHAR *pucCookie,UCHAR *pucTokenId)
```

Check SVNWebProxyCookie cookie.
Assume something like SVNWebProxyCookie=<token>
Skip "SVNWebProxyCookie", copy token until delimiter (;, ' ' or '\0')

Copies characters from `cookie_ptr + 18` ("SVNWebProxyCookie=") into pucTokenId until it hits ; or \0 or a space - basically, the token

# vrp

`ELF 32-bit MSB shared object, MIPS, N32 MIPS64 rel2 version 1 (SYSV), dynamically linked, interpreter /lib32/ld.so.1, for GNU/Linux 2.6.34, with debug_info, not stripped`

> VRP is Huaweiâ€™s network operating system that runs on network devices such as routers and switches.

A lot of functions from vrp are using wrappers around other functions.

`size_t VOS_StrLen(longlong param_1)` -> this is a wrapper around `strlen`. It first checks if `param_1` is null.
`char * vrp_inet_ntop(short param_1,byte *param_2,char *param_3,ulonglong param_4)` -> this is a wrapper around `inet_ntop`, add some security checks.

## CLI Console

The `WCLI_*` functions are handling the different features of the CLI Console.

> WCON = Web console user terminal interface

## HTTPd

The `HTTPD_PRS_PackResponseHeader` function reveals many endpoint and logic for the HTTP server.
The `HTTPD_PRS_ParseRequestHeader` function handles requests.

szPath -> endpoint

#### HTTPD_PRS_ParseRequestHeader

If we send a HTTP request containing the "Token" header it will set `(pstHttpdCtl->stReqHeader).RequestLine.szToken` to it

#### HTTPD_CheckSession

It handles the "SESSIONID" cookie. It copies the base64 decoded SESSIONID cookie to the `szSessionID` buffer.

## SESSIONID

This is an example of how SESSIONID looks like: `mQAAALirwetGRZ1HYFFN6RAQyVYc6kWN4WYtiVXW/kQ=&mQAAABMDB881k4kT4KzHQg==&HUAWEI &langfrombrows=en-GB,&copyright=2014-2018`
Each fields are separated by `&`. The first part is the session identifier. The second part is a CSRF protection. 

Once base64 decoded the session identifier is 32 bytes. 


| Value                                        | Size     | Purpose                    |
|----------------------------------------------|----------|----------------------------|
| mQAAALirwetGRZ1HYFFN6RAQyVYc6kWN4WYtiVXW/kQ= | 32 bytes | Primary session identifier |
| mQAAABMDB881k4kT4KzHQg==                     | 16 bytes | CSRF protection            |
| HUAWEI                                       | -        | static                     |
| langfrombrows=en-GB                          | -        | client language            |
| copyright=2014-2018                          | -        | static                     |


The primary session identifier is called `szSessionID`, this is the first field in the `HTTPD_USER_SESSION` struct. 

The SESSIONID is generated via the `HTTPD_GenerateCookie` function which in turn relies on `HTTPD_UTIL_GenRandNum()`. The first 4 bytes of the SESSIONID are derived from the socket descriptor (referred to as `_ulGlobalId`). 

The remaining bytes are generated by OpenSSL's `RAND_bytes()`.  

The first 4 bytes could eventually be determined, but the remaining 28 bytes could not. We are left with $2^{224}$ possible combinations...

### On requests

The `HTTPD_CheckSession` function is calling `HTTPD_WRAPPER_Hash_FindNode` to verify if the SESSIONID cookie is valid. If it is the `HTTPD_CheckSessionIP()` function is called to verify if the user's IP correspond to the IP saved with the SESSIONID.

Because of this, in theory, even if an attacker steal a SESSIONID cookie, they should not be able to log in.


---

## Structs

```c
struct tagHTTPD_TASK_CTL_STRU {
    ulong ulTaskid;
    long lsAcptSocket;
    ulong ulGlobalId;
    long lSvrSocket;
    UCHAR szHdrsRcvBuf[5121];
    ulong ulHdrsRcvdLen;
    long lHdrsFlgRcv:16;
    long lHdrsFlgSnd:16;
    ulong ulSendBuffLen;
    ulong ulHasSend;
    UCHAR *pszRemainDataptr;
    UCHAR *pszBodyRcvBuf;
    ulong ulBodyRcvdLen;
    ulong ulUploadRcvdLen;
    UCHAR szFileName[161];
    ulong ulFileEndLen;
    long lHandle;
    ulong ulSessionIndex;
    HTTP_REQUEST stReqHeader;
    HTTP_RESPONSE stResHeader;
    UCHAR *pszSendBuff;
    long lTimeOut;
    HTTP_IPADDR stUserIP;
    ulong ulUserPort;
    ulong ulDestIP;
    ulong ulDestPort;
    ulong ulLifeTime;
    ulong ulStatusCode;
    ulong *pSSL;
    ulong ulHandshakeDone;
    ulong ulHandshakeCnt;
    long lSendDataHandle;
    long *SendDatafd;
    uint ulSendDataFlag;
    ulong res;
    ulong ulSendDataRemainLen;
    HTTPD_SVR_TYPE enumSessType;
    ulong ulFileDeleteFlag;
    ulong ulWriteToFlash;
};
```